# -*- coding: utf-8 -*-
"""ML_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lBboYJ80GhpQDRM_vqwZPV9ZELzm9pfd
"""

import numpy as np
import pandas as pd
import io
import math
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import StandardScaler
import seaborn as sns
from sklearn.metrics import log_loss
from google.colab import files 
# files =files.upload()
from sklearn.cluster import KMeans
from pydrive.auth import GoogleAuth
from google.colab import drive
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)
file_id = '1TFqjf3W3juzjUUicmiEqBjitBnR8753k'
download = drive.CreateFile({'id': file_id})
download.GetContentFile('proj_input.csv')
df  = pd.read_csv("proj_input.csv")
dataframe=df
dataframe.head()

def get_features(input_mood):
	if input_mood == 'Happy':
		features=['danceability', 'valence']
	elif input_mood == 'Sad':
		features=['danceability', 'valence']
	elif input_mood == 'Party':
		features=['danceability', 'energy']
	elif input_mood == 'Calm':
		features=['loudness', 'tempo']
	elif input_mood == 'Energetic':
		features=['loudness', 'energy']
	return features

def assign_weight(v):
	if v == 'Happy':
		# Adding weight
		weight = [0.0,0.0,0.10,0.0,0.0,0.0,0.0,0.9]
	
	elif v == 'Sad':
		# Adding weight
		weight = [0.0,0.0,0.10,0.0,0.0,0.0,0.0,0.9]
	
	elif v == 'Party':
		# Adding weight
		weight = [0.0,0.0,0.10,0.9,0.0,0.0,0.0,0.0]
	
	elif v == 'Calm':
		# Adding weight
		weight = [0.0,0.0,0.0,-0.9,0.0,-0.10,0.0,0.0]
	
	elif v == 'Energetic':
		# Adding weight
		weight = [0.0,0.0,0.10,0.9,0.0,0.10,0.0,0.9]
	return weight

def plot_cluster(data,kmeans):
  label = kmeans.fit_predict(data)
  filtered_label0 = data[label == 0]
  filtered_label1 = data[label == 1]
  filtered_label0
  plt.scatter(filtered_label0.iloc[:,2] , filtered_label0.iloc[:,-2] , color = 'green')
  plt.scatter(filtered_label1.iloc[:,2] , filtered_label1.iloc[:,-2] , color = 'red')
  plt.show()

#get valence of the input song

def get_data(dataframe,input_mood):
  dataframe.drop(dataframe.columns[[0,1,2,3,7,-8,-7,-5,-4,-2]], 1, inplace = True)
  scl = StandardScaler()
  df=scl.fit_transform(dataframe)
  print(df)
  data=pd.DataFrame(df,columns=['popularity','acousticness','danceability','energy','instrumentalness','loudness','tempo','valence'])
  print(data)
  if 'label' in data:
    data=data.drop(columns=['label'])
  col=len(data.columns)
  weight = assign_weight(input_mood)
  for i in range(col-1):
    data.iloc[:,i]  = data.iloc[:,i] .apply(lambda x: x*weight[i])
  data
  kmeans = KMeans(n_clusters=2, random_state=0).fit(data)
  # Y = np.array(data['valence'].astype(float))
  # predict=kmeans.predict(data, sample_weight = Y)
  predict=kmeans.predict(data)
  data['label'] = pd.Series(predict, index=data.index)
  print(data[data['label']==0])
  return data,kmeans
# feature0 = not
# feature1 = PC

def find_songs(data,kmeans,features):
  round_off=3
  adata = data[features]
  print(adata)
  f0=features[0]
  f1=features[1]
  print("adata is ", adata)
  adata=adata.round({f0:round_off, f1:round_off})
  print("rounded off data is ",adata)
  adata.drop_duplicates(keep=False, inplace=True)
  example=adata.sample()
  f0_current=round(float(example.iloc[:,0]),3)
  f1_current=round(float(example.iloc[:,1]),3)

  # f0_current=0.661
  # f0_current=-1.5
  current_mood = 0
  centre_length = len(kmeans.cluster_centers_[0])
  if centre_length == 8:
    centers_temp = pd.DataFrame(kmeans.cluster_centers_, columns =['popularity' , 'acousticness' , 'danceability' , 'energy' , 'instrumentalness' , 'loudness' , 'tempo' , 'valence'])  
  if centre_length == 9:
    centers_temp = pd.DataFrame(kmeans.cluster_centers_, columns =['popularity' , 'acousticness' , 'danceability' , 'energy' , 'instrumentalness' , 'loudness' , 'tempo' , 'valence' , 'extra'])
  
  #centers_temp=centers_temp[features].round({f0:round_off, f1:round_off})
  centers_temp=centers_temp[features].round({f0:round_off, f1:round_off})
  #.loc[(centers_temp.valence > 0)]
  centers_temp=centers_temp[centers_temp.select_dtypes(include=[np.number]).ge(0).all(1)]
  p1_org = adata.loc[(adata.iloc[:,0] == f0_current)&(adata.iloc[:,1] == f1_current)].to_numpy()
  p3=p1_org
  p1=p1_org
  p2 = centers_temp.to_numpy()
  print("p1 and p2 are initially ", p1,p2)
  initial_distance=np.linalg.norm(p1 - p2)
  span = 0.2
  songs=1
  up=find_dist(adata,f0_current,span,initial_distance,p1,p2,songs)
  return up

def find_dist(adata,valence_current,span,current_distance,p1,p2,songs):
  print("current distance is ",current_distance)
  dist=0
  updated_distance=current_distance
  updated_valence=valence_current
  current_span=valence_current + span
  # print("current_span is ", current_span)
  # print("valence_current is ", valence_current)
  # print("adata is ", adata)
  # print("fdeheksjh",adata.loc[(adata.iloc[:,1] > valence_current) & (adata.iloc[:,1] < current_span)].to_numpy())
  jdata = adata.loc[(adata.iloc[:,1] > valence_current) & (adata.iloc[:,1] < current_span)].to_numpy()
  #print("Jdata is ", jdata)
  if(len(jdata>0)):
    count=int(len(jdata))
    for i in range(count):
      p3 = jdata[i]
      dist = np.linalg.norm(p3 - p2) 
      if dist<current_distance and dist >=0:
        current_dist=dist
        p1=p3
    print("p1 and p2 are now ", p1,p2)
    updated_distance=np.linalg.norm(p1 - p2)
    # print(type(p1),type(p2))
    # print("p1 is ",p1)
    # if isinstance(p1,np.ndarray):
    #   updated_valence=p1[0][1]
    # else:
    if(len(p1)>1):
      updated_valence=p1[1]
    else:
      updated_valence=p1[0][1]
    updated_distance=np.linalg.norm(p1 - p2)
    if updated_valence<p2[0][1]:
      song=find_dist(adata,updated_valence,span,updated_distance,p1,p2,songs)
      songs = songs+song
  else:
    if(updated_valence<p2[0][1]):
      print("Inside else")
      updated_valence=current_span+span
      print(updated_valence)
      find_dist(adata,updated_valence,span,updated_distance,p1,p2,songs)
  return (songs)

def plot_cluster(data,kmeans):
  label = kmeans.fit_predict(data)
  filtered_label0 = data[label == 0]
  filtered_label1 = data[label == 1]
  filtered_label0
  plt.scatter(filtered_label0.iloc[:,2] , filtered_label0.iloc[:,-2] , color = 'green')
  plt.scatter(filtered_label1.iloc[:,2] , filtered_label1.iloc[:,-2] , color = 'red')
  plt.show()

input_mood="Sad"
data,kmeans=get_data(dataframe,input_mood)
features=get_features(input_mood)
print(features)
plot_cluster(data,kmeans)
songs=find_songs(data,kmeans,features)
songs